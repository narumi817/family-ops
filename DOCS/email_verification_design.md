# メールアドレス確認機能のデータベース設計

## 設計方針

メールアドレス確認用のトークンは一時的なデータのため、`users`テーブルに直接追加するのではなく、別テーブルに分離します。

## 設計パターン

### パターン1: email_verificationsテーブル（推奨）

確認トークン専用のテーブルを作成し、確認済みの情報は削除します。`email_verified_at`のみ`users`テーブルに残します。

#### email_verificationsテーブル

| カラム名 | 論理名 | 型 | NULL | デフォルト | 説明 |
|---------|--------|-----|------|-----------|------|
| id | ID | bigint | false | - | 主キー |
| user_id | ユーザーID | bigint | true | - | 外部キー（メールアドレス確認時点ではユーザー未作成の可能性） |
| email | メールアドレス | string | false | - | 確認対象のメールアドレス（ユーザー未作成時のため必要） |
| token | 確認トークン | string | false | - | ユニーク制約あり |
| token_expires_at | トークン有効期限 | datetime | false | - | - |
| verified_at | 確認日時 | datetime | true | - | 確認完了時に設定 |
| created_at | 作成日時 | datetime | false | - | - |
| updated_at | 更新日時 | datetime | false | - | - |

**インデックス:**
- `email_verifications_token_unique` (UNIQUE): `token`
- `email_verifications_email_index`: `email`
- `email_verifications_user_id_index`: `user_id` (NULL可)

**特徴:**
- メールアドレス確認時にユーザーが未作成の可能性があるため、`user_id`はNULL許可
- 確認完了後、トークンレコードは削除（または`verified_at`を設定して保持）
- `users.email_verified_at`に確認日時を記録

#### usersテーブルに追加

| カラム名 | 論理名 | 型 | NULL | デフォルト | 説明 |
|---------|--------|-----|------|-----------|------|
| email_verified_at | メールアドレス確認日時 | datetime | true | - | 確認完了日時（一度設定されたら変更不可） |

### パターン2: user_email_verificationsテーブル

`user_id`を必須にし、ユーザー作成後にトークンを生成する方式（初期サインアップには不向き）

## メリット・デメリット

### パターン1（推奨）のメリット

1. **データのクリーン性**
   - 確認済みユーザーには不要なトークン情報が残らない
   - `users`テーブルがシンプルに保たれる

2. **履歴管理**
   - 複数回メール送信された場合でも履歴を管理可能
   - 確認前のトークンを複数持てる

3. **柔軟性**
   - ユーザー未作成時でもトークンを発行可能（初期サインアップに対応）

4. **セキュリティ**
   - 確認済みのトークンを削除することで、再利用を防げる

### パターン1のデメリット

1. **テーブル数が増える**
   - ただし、適切な分離のため許容範囲

2. **JOINが必要**
   - トークン検証時にはJOINが必要（ただし、トークンは一時的なため問題なし）

### パターン2のデメリット

1. **初期サインアップに不向き**
   - ユーザー未作成時にトークンを発行できない

## 推奨設計

**パターン1を推奨**します。

理由：
- 初期サインアップの要件（ユーザー未作成時のトークン発行）に対応できる
- データのクリーン性が保たれる
- 確認済みトークンの自動削除や履歴管理がしやすい

## 実装方針

1. `email_verifications`テーブルを作成
   - `user_id`: NULL許可（ユーザー未作成時に対応）
   - `email`: 必須（トークン発行時にユーザーが存在しない場合があるため）
   - `token`: UNIQUE制約
   - `token_expires_at`: 必須（デフォルト：24時間後など）

2. `users`テーブルに`email_verified_at`を追加
   - 確認日時を永続的に記録

3. 確認完了後の処理
   - トークンレコードを削除（または`verified_at`を設定）
   - `users.email_verified_at`に確認日時を設定

4. 古いトークンのクリーンアップ
   - 期限切れトークンは定期バッチで削除

## 招待トークンとの関係

`family_invitations`テーブルは既に別テーブルとして設計されていますが、同様の設計思想です：

- 一時的なトークン情報は専用テーブルで管理
- 招待受諾後は削除または`accepted_at`を設定
- 家族情報は`families`や`family_members`テーブルに永続化

この設計思想は`email_verifications`にも適用できます。

